# FormalLanguagesTasks
2. Даны α и натуральные числа k, l, такие что 0 ≤ l < k. Вывести минимальное
число n, равное l по модулю k, такое что L содержит слова длины n.

Для решения задачи 2 воспользуемся следующим алгоритмом: 

Идея:
Заведем бинарное дерево, в листьях, которого будем хранить буквы нашей регулярки, а во всех нелистовых вершинах будем хранить бинарную операцию, которую надо применить к левому и правому сыну (в таком порядке) или звезду Клини, которую надо применить только к левому сыну. Также в каждой вершине V будем хранить вектор (min_len_ в коде программы) длины k такой, что в i-й ячейке вектора будет храниться минимальная длина слова len такая, что len % k = i, и слово длины len распознается регуляркой, задающейся деревом с корнем в вершине V. Тогда ответ будет лежать в l-й ячейке вектора корня.

Реализация:
Будем подсчитывать ответ по мере построения дерева. Для листовых вершин min_len_[i] = 1 (база индукции), а остальные значения - INF. Рассмотрим нелистовую вершину V, пусть ее дети - left и right (если V отвечает за звезду Клини то только left). 

(предположение индукции в том, что для left и right алгоритм работает корректно)

1 случай: в V хранится +
Заметим, что в таком случае регуляркой, задающейся деревом с корнем в V распознаются все слова, которые распознаются left или right. Тогда min_len_[i] = min(left.min_len_[i], right.min_len_[i]). (корректность очевидна)

2 случай: в V хранится . (конкатенация)
В этом случае рассмотрим всевозможные суммы s = (l + r) % k такие, что left.min_len_[l] и right.min_len_[r] не равны INF, т.е. слова длины остатков l и r распознаются деревьями с корнями в left и right, при этом в l и r ячейках min_len_ детей хранятся слова наименьшей возможной длины остатков l и r соответственно (предположение индукции). Тогда пройдемся по всем не INF значениям left и для каждого такого значения посмотрим на все не INF значения right. Тогда min_len_[i] = min(min_len_[i], left.min_len_[l] + right.min_len_[r]), где i = (l + r) % k. (корректность также очевидна)

3 случай в V хранится *
Воспользуемся итеративным алгоритмом:

Заведем вектор new_residues, куда будем складывать всевозможные получившиеся остатки на одной конкретной итерации. Изначально (до 1 итерации) в new_residues лежат все такие i, что left.min_len_[i] != INF. Также до запуска цикла (необходимого в алгоритме) запишем в min_len_[i] left.min_len_[i] (т.к. эти слова распознаются первой степенью регулярки left). Также заведем вектор cur_residues в котором на итерации с номером N (N >= 0) будут лежать все остатки, полученные в new_residues на (N-1)-ой итерации. Также заведем set all_residues, в который будем складывать всевозможные остатки такие, что регуляркой left под звездой Клини можно распознать слово, дающее такой остаток. Перед первой итерацией all_residues пусто. (set cur_all_residues в программе для удобства)

Теперь итерации:
1) Переложим содержимое new_residues в cur_residues и очистим new_residues.
2) Пройдем по всем значения i в cur_residues:
    2.1) Для значения i пройдем по всем значениям j сета all_residues, получим s = (i + j) % k, это означает, что слово длины остатка s можно распознать регуляркой left под звездой Клини. Слова длин остатков i и j также можно было распознать регуляркой т.к. они появились до этой итерации. Значит min_len_[s] = min(min_len_[s], min_len_[i] + min_len_[j]) - верно на конкретной итерации цикла. Если s нет в all_residues то добавим его туда, а в new_residues добавим s - получили новый остаток.
    2.2) Для значения i пройдем по всем значениям j вектора cur_residues, получим s = (i + j) % k, это означает, что слово длины остатка s можно распознать регуляркой left под звездой Клини. Слова длин остатков i и j также можно было распознать регуляркой т.к. они появились до этой итерации. Значит min_len_[s] = min(min_len_[s], min_len_[i] + min_len_[j]) - верно на конкретной итерации цикла. Если s нет в all_residues то добавим его туда, а в new_residues добавим s - получили новый остаток.
Если в какой-то момент получится, что новые остатки получить нельзя, значит итерироваться дальше нет смысла - мы не получим новых остатков (и новых длин слов для min_len_), поэтому в этом случае выйдем из внешнего цикла. Пронумеруем итерации. На N-й итерации было верно "min_len_[s] = min(min_len_[s], min_len_[i] + min_len_[j])" значит это будет верно и после выполнения всех итераций для всевозможных s таких, что слово длины, дающей остаток s распознается в вершине V. Т.е. мы получили требуемое - в s-й ячейке min_len_ лежит минимальная длина (сравнимая с s по k) слова распознаваемого в V.
Осталось записать min_len_[0] = 0 (звездой Клини распознаем пустое слово)

Для каждой операции подсчет ответа по мере построения корректен, значит можем перейти в корень и посмотреть на l-ю ячейку.
